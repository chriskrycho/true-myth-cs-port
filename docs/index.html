<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Introduction | True Myth </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Introduction | True Myth ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="images/logo_header.png">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="images/logo_header.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="introduction">Introduction</h1>

<p>True Myth provides standard, type-safe wrappers and helper functions to help you with two
<em>extremely</em> common cases in programming:</p>
<ul>
<li>not having a value — which it solves with a <code>Maybe</code> type and associated helper
functions and methods</li>
<li>having a result where you need to deal with either success or failure — which it solves
with a <code>Result</code> type and associated helper functions and methods</li>
</ul>
<p>You could implement all of these yourself – it’s not hard! – but it’s much easier to just
have one extremely well-tested library you can use everywhere to solve this problem once
and for all.</p>
<p>Even better to get one of these with no runtime overhead for using it other than the very
small cost of some little container objects — which we get by leaning hard on the type
system in C♯.</p>
<p>Aside: If you’re familiar with <a href="https://github.com/louthy/language-ext">LanguageExt</a>,
you'll see that this has a lot in common with it — its main differences are:</p>
<ul>
<li>True Myth has a much smaller API surface than LanguageExt</li>
<li>True Myth aims to be much more approachable for people who aren’t already super
familiar with functional programming concepts and jargon</li>
</ul>
<h2 id="maybe">Maybe</h2>
<p>Sometimes you don’t have a value. In C♯ (and .NET generally), we usually represent that
with a <code>null</code> - either directly or by a <code>Nullable&lt;T&gt;</code> — and then trying to program
defensively in the places we think we might get <code>null</code> as arguments to our functions. For
example, imagine an endpoint which returns a JSON payload shaped like this:</p>
<pre><code class="lang-json">{
  &quot;hopefullyAString&quot;: &quot;Hello!&quot;
}
</code></pre>
<p>But sometimes it might come over like this:</p>
<pre><code class="lang-json">{
  &quot;hopefullyAString&quot;: null
}
</code></pre>
<p>Or even like this:</p>
<pre><code class="lang-json">{}
</code></pre>
<p>Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In typical C♯ we’d write something like this:</p>
<pre><code class="lang-csharp">void LogValue(PayloadDto payload)
{
  var length = payload?.hopefullyAString?.Length();
  loger.Debug(&quot;Payload length: {length}&quot;, length);
}

async Task RequestFromApi()
{
  await client.FetchFromApi()
              .ContinueWith(payload =&gt; {
                LogValue(payload);
                // other stuff with payload ...
              });
}
</code></pre>
<p>This isn’t a big deal right here… but — and this is a big deal — we have to remember to do
this everywhere we interact with this payload. The property <code>hopefullyAString</code> can always
be <code>null</code> everywhere we interact with it, anywhere in our program. 😬</p>
<p><code>Maybe</code> is our escape hatch. If, instead of just naively interacting with the payload, we do a very small amount of work
up front to normalize the data and use a <code>Maybe</code> instead of passing around <code>null</code> values, we can operate safely on the
data throughout our application. If we have something, we get <code>Maybe</code> called <strong>Just</strong> — as in, “What’s in this field?
Just a string” or “Just the string ‘hello’”. If there’s nothing there, we have a <code>Maybe</code> called <strong>Nothing</strong>. <code>Maybe</code> is
a wrapper type that holds the actual value in it, and <strong>Just</strong> and <strong>Nothing</strong> are the valid states for that type.
You’ll never get a <code>NullReferenceException</code> (&quot;object reference not set to an instance of an object&quot;) when trying to use
it!</p>
<p>Importantly, you can do a bunch of neat things with a <code>Maybe</code> instance without checking whether it’s a <strong>Nothing</strong> or a
<strong>Just</strong>. For example, if you want to double a number if it’s present and do nothing if it isn’t, you can use the
<code>Maybe.Map</code> function:</p>
<pre><code class="lang-csharp">var hereIsANumber = Maybe.Of(42); // Maybe&lt;int&gt;
var hereIsNothing = Maybe&lt;int&gt;.Nothing;

int doubleFn = n =&gt; n * 2;
hereIsANumber.Map(doubleFn); // Just 84
hereIsNothing.Map(doubleFn); // Nothing
</code></pre>
<p>There are a lot of those <a href="">helper functions and methods</a>! Just about any way you would
need to interact with a Maybe is there.</p>
<p>So now that we have a little idea what <code>Maybe</code> is for and how to use it, here’s that same
example, but rewritten to normalize the payload using a <code>Maybe</code> instance. We’re using C♯,
so we will get a compiler error if we don’t handle any of these cases right — or if we try
to use the value at <code>hopefullyAString</code> directly after we’ve normalized it!</p>
<pre><code class="lang-csharp">class PayloadDto
{
  public string HopefullyAString { get; set; }
}
class Payload
{
  public Maybe&lt;string&gt; HopefullyAString { get; set; }
}

async Task&lt;Payload&gt; Normalize(PayloadDto dto) =&gt; 
  return Task.FromResult(new Payload { 
    HopefullyAString = Maybe.Of(dto.HopefullyAString) 
  });

void LogValue(Payload payload)
{
  var length = payload.HopefullyAString.MapReturn(s =&gt; s.Length, 0);
  loger.Debug(&quot;Payload length: {length}&quot;, length);
}

async Task RequestFromApi()
{
  await client.FetchFromApi()
              .ContinueWith(Normalize)
              .ContinueWith(LogValue);
}

</code></pre>
<p>Now, you might be thinking, <em>Sure, but we could get the same effect by just supplying a default value when we
deserialize the data.</em> That’s true, you could! Here, for example, you could just normalize it to an empty string. And of
course, if just supplying a default value at the API boundary is the right move, you can still do that. <code>Maybe</code> is
another tool in your toolbox, not something you’re obligated to use everywhere you can.</p>
<p>However, sometimes there isn’t a single correct default value to use at the API boundary. You might need to handle that
missing data in a variety of ways throughout your application. For example, what if you need to treat “no value”
distinctly from “there’s a value present, and it’s an empty string”? That’s where <code>Maybe</code> comes in handy.</p>
<h2 id="result">Result</h2>
<p>Another common scenario we find ourselves in is dealing with operations which might fail. The most common pattern in
.NET for dealing with this: <em>exceptions</em>. There are major problems with exception, especially around reusability and
composability.</p>
<p>Exceptions are unpredictable: you can’t know whether a given function invocation is going to throw an exception until
runtime as someone calling the function. No big deal if it’s a small application and one person wrote all the code, but
with even a few thousand lines of code or two developers, it’s very easy to miss that. And then this happens:</p>
<pre><code class="lang-csharp">// in one part of the codebase
object GetMeAValue(sring url) {
  if (IsMalformed(url)) {
    throw new Exception($&quot;The url `{url}` is malformed!&quot;);
  }
  
  // do something else to load data from the URL
  return data;
}

string RenderHtml(object toRender) {
  // if toRender can't generate valid HTML, throw Error(&quot;invalid HTML&quot;);
  // if it can, theRenderedHTML;
}

void WriteOutput(string html)
{
  // I/O
}

// somewhere else in the codebase -- throws an exception
var badUrl = &quot;http:/www.google.com&quot;;  // missing a slash
var response = GetMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
var htmlForPage = RenderHtml(value);

// so we definitely can't get here safely
WriteOutput(htmlForPage);
</code></pre>
<p>Notice: there’s no way for the caller to know that the function will throw. Perhaps you’re
very disciplined and write good docstrings for every function – and moreover, perhaps
everyone’s editor shows it to them and they pay attention to that briefly-available
popover. More likely, though, this exception throws at runtime and probably as a result of
user-entered data – and then you’re chasing down the problem through error logs. More, if
you do want to account for the reality that any function anywhere in C♯ might
actually throw, you’re going to write something like this:</p>
<pre><code class="lang-csharp">try
{
  var badUrl = &quot;http:/www.google.com&quot;;  // missing a slash
  var response = GetMeAValue(badUrl);  // throws here

  // we never get here, but it could throw too
  var htmlForPage = RenderHtml(value);

  // so we definitely can't get here safely
  WriteOutput(htmlForPage); 
}
catch(Exception exn)
{
  HandleErr(exn);
}
</code></pre>
<p>This kind of universal boilerplate works against the Don't Repeat Yourself principle, and C♯ can’t help you here!
There's no type signatures to say “This throws an exception!”</p>
<p>Instead, we can use a <code>Result</code> to get us a container type, much like <code>Maybe</code>, to let us deal with this scenario. A
<code>Result</code> is either an <strong>Ok</strong> wrapping around a value (like <strong>Just</strong> does) or an <strong>Err</strong> wrapping around some type
defining what went wrong (unlike <strong>Nothing</strong>, which has no contents).</p>
<pre><code class="lang-csharp">Result&lt;Payload, string&gt; GetMeAValue(string url)
{
  if (IsMalformed(url)) {
    return Result&lt;Payload, string&gt;.Err($&quot;The url '{url}' is malformed&quot;);
  }
  
  // do something else to load data from the url
  return Result.Ok(data);
}

Result&lt;string, string&gt; RenderHtml(string toRender)
{
  // if toRender can't generate valid HTML, return Err(&quot;invalid HTML&quot;);
  // if it can, return Ok(theRenderedHTML);
}

void WriteOutput(string html)
{
  
}

// somewhere else in the codebase -- no exception this time!
var badUrl = &quot;http:/www.google.com&quot;;  // missing a slash

// value = Err(The url '${http:/www.google.com}' is malformed)
var value = GetMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
var htmlForPage = value.AndThen(RenderHtml);

value.Match(
  ok: html =&gt; WriteOutput(html.UnwrapOr(string.Empty));
  err: reason =&gt; Alert($&quot;Something went seriously wrong here! {reason}&quot;);
)
</code></pre>
<p>When we have a <code>Result</code> instance, we can perform tons of operations on whether it’s <strong>Ok</strong> or <strong>Err</strong>, just as we could
with a <strong>Just</strong> and <strong>Nothing</strong>, until we need the value. Maybe that’s right away. Maybe we don’t need it until
somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/true-myth/true-myth-csharp/blob/master/docsrc/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
